--[[
Contains a set of functions to acheive on-the-fly DICOM tag
modification on Orthanc DICOM server, which enables to:
(1) Fix DICOM tag inconsistency across scanners and console OS verions
(2) Generate Flywheel identification string to specify the location
    where the data should be stored to.
]]

function generateFwDataPath(subjectLabel, programLabel)
    -- Generate Flywheel data path that specifies where
    -- the incoming data should be stored.
    -- Format: '[subject_label]@[Group_ID]/[Project_Label]'
    local fmtStr = '%s@%s/%s'
    --
    -- Input arguments:
    --   [subjectLabel] Subject from which the data is acquired.
    --
    --   [programLabel] The sequence program identifier is expected to be
    --     formatted as 'Institution^Group^Project'.
    --     This ID is generated by Siemens MRI console, which concanetates
    --     the fist- and second-level node labels of the sequence program
    --     selected from the tree structured program directory.
    --
    --     E.g.) [1st-level label]  [2nd-level label]  =>  [programLabel]
    --           'MyInst'             'MyGroup'             =>  'MyInst^MyGroup'
    --           'MyInst'             'MyGroup^MyProj'      =>  'MyInst^MyGroup^MyProj'
    --           'MyInst^MyGroup'     'MyProj'              =>  'MyInst^MyGroup^MyProj'
    --
    --     Note: Delimiters to tokenize the string can be customized in splitProgramLabel()
    --           (default delimiters are '^ @:#>')
    --
    -- Conversion rules:
    --   * [subjectLabel] (input arg) is direclty mapped to
    --     [subject_label] (Flywheel data path)
    --
    --   * [programLabel] (input arg) is split into tokens, then used to generate
    --     [Group_ID] and [Project_Lable] (Flywheel data path) as follows:
    --        - [Group_ID]      : '[token#1]_[token#2]'
    --        - [Project_Label] : '[token#3]'
    --                            (or set to 'default' if [token#3] is blank)

    local tokens = splitProgramLabel(programLabel)

    local groupLabel = 'unknown'
    local projectLabel = 'unknown'
    if #tokens >= 2 then
        groupLabel = string.lower(tokens[1] .. '_' .. tokens[2])
        if #tokens < 3 then
            projectLabel =  'default'
        else
            projectLabel = table.concat(tokens,'_',3,#tokens)
        end
    end

    return fmtStr:format(subjectLabel,groupLabel,projectLabel)
end

function generateFwSessionLabel(stationName, studyDate, studyTime)
    -- Generate a session label used by Flywheel to group acquisitions
    -- that belong to the same session. The steps for the conversion are:
    --
    --   1. Convert [stationName] (input arg) to [scannerLabel]
    --      E.g.) 'MRC35466' -> 'MRI-3T-TrioTim'
    --
    --   2. Convert [studyDate] and [studyTime] (input args) into
    --      human readable format, 'YYYY-MM-DDThh:mm:ss'.
    --      E.g.) '20190319', '134940.794000' -> '2019-03-19T13:49:40'
    --
    --   3. Concatenate 1 and 2 to generate final Flywheel session label
    --      E.g.) 'MRI-3T-TrioTIM_2019-03-19T13:49:40'

    local scannerLabel = stationName2scannerLabel(stationName)
    local strDate = string.gsub(studyDate, '^(%d%d%d%d)(%d%d)(%d%d).*', '%1-%2-%3')
    local strTime = string.gsub(studyTime, '^(%d%d)(%d%d)(%d%d).*', '%1:%2:%3')

    return scannerLabel .. '_' .. strDate .. 'T' .. strTime
end

function stationName2scannerLabel(stationName)
    -- Mapping stationName to scannerLabel
    mapScannerId2Label = { ['MRC35466']  = 'MRI-3T-TrioTim',
                        ['AWP66083']  = 'MRI-3T-Prisma',
                        ['AWP175680'] = 'MRI-3T-Vida' }

    local scannerLabel = 'unknown'
    for key, value in pairs(mapScannerId2Label) do
        if stationName == key then
            scannerLabel = value
        end
    end

    return scannerLabel
end

function splitProgramLabel(programLabel)
    local delimiters = '^ @:#>' -- Delimiters used to parse
    return split(programLabel, delimiters)
end

function fixStudyDescription(studyDescription, ppsDescription, manufacturerModelName)
    local ret = studyDescription
    if manufacturerModelName == 'MAGNETOM Vida' then  -- Work around for Vida bug
        if studyDescription == '' then
            ret = ppsDescription
        end
        -- ret = string.gsub(ret, '%s', '^')
    end
    return ret
end

function OnStoredInstance(instanceId, tags, metadata, origin)
    -- Check origin to avoid infinite loop
    if origin['RequestOrigin'] ~= 'Lua' then
        -- Retrieve info required to generate new tags
        local patientId = tags['PatientID']
        local patientComments = tags['PatientComments']
        local studyDescription = tags['StudyDescription']
        local ppsDescription = tags['PerformedProcedureStepDescription']
        local manufacturerModelName = tags['ManufacturerModelName']
        local stationName = tags['StationName']
        local studyDate = tags['StudyDate']
        local studyTime = tags['StudyTime']
        local accessionNumber = tags['accessionNumber']

        studyDescription = fixStudyDescription(studyDescription, ppsDescription, manufacturerModelName)

        -- Generate new tags
        local fwDataPath = generateFwDataPath(patientId, studyDescription)
        local fwSessionLabel = generateFwSessionLabel(stationName, studyDate, studyTime)

        -- Set tags to be replaced
        local replace = {}
        if (patientComments == nil) or (patientComments == '') then
            replace['PatientComments'] = fwDataPath
        end
        replace['StudyDescription'] = fwSessionLabel
        replace['AccessionNumber'] = 'Flywheel'

        -- Set tags to be removed
        local remove = {}

        -- Modify the instance
        local command = {}
        command['Replace'] = replace
        command['Remove'] = remove
        local ret = ModifyInstance(instanceId, replace, remove, true)

        -- Delete the original instance
        Delete(instanceId)
    else
        -- Reconstruct metadata for the modified instance
        local ret = RestApiPost('/instances/' .. instanceId .. '/reconstruct', '{}')
    end
end

function ReceivedInstanceFilter(tags, origin)
    -- Check origin to avoid infinite loop
    if origin['RequestOrigin'] == 'Lua' then
        return true
    else
        -- Retrieve info needed to judge whether to accept the data or not
        local studyDescription = tags['StudyDescription']
        local ppsDescription = tags['PerformedProcedureStepDescription']
        local manufacturerModelName = tags['ManufacturerModelName']
        studyDescription = fixStudyDescription(studyDescription, ppsDescription, manufacturerModelName)
        local tokens = splitProgramLabel(studyDescription)

        -- Rules for filtering incoming data
        if contains({'InstA', 'InstB'}, tokens[1]) then
            return true
        else
            return false
        end
    end
end

-- Utility functions

function split(s, delimiters)
    local delimiter = string.sub(delimiters, 1, 1) -- 1st delimiter
    local delimsRegex = string.gsub(delimiters,
        '[%(%)%.%%%+%-%*%?%[%^%$]','%%%0') -- escape regex reserved characters
    delimsRegex = string.gsub(delimsRegex,'%s','%%s') -- replace ' ' with '%s'
    local tokens = {}
    for match in (s..delimiter):gmatch('(.-)['..delimsRegex..']') do
        table.insert(tokens, match)
    end
    return tokens
end

function contains(list, str)
    for key, value in pairs(list) do
        if value == str then
            return true
        end
    end
    return false
end

function getDicomTag(dicomTags, key)
    local info = dicomTags[key]
    if info ~= nil then
        return dicomTags[key]['Value']
    else
        return nil
    end
end
